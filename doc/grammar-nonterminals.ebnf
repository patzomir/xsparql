/* This format can be fed to http://bottlecaps.de/rr/ui */

/* XQuery Non terminals */
/*[1]*/  	Module	  ::=  	VersionDecl? (LibraryModule | MainModule)
/*[2]*/  	VersionDecl	  ::=  	"xquery" "version" StringLiteral ("encoding" StringLiteral)? Separator
/*[3]*/  	MainModule	  ::=  	Prolog QueryBody
/*[4]*/  	LibraryModule	  ::=  	ModuleDecl Prolog
/*[5]*/  	ModuleDecl	  ::=  	"module" "namespace" NCName "=" URILiteral Separator
/*[6]*/  	Prolog	  ::=  	BaseDecl?(((DefaultNamespaceDecl | Setter | NamespaceDecl | ImportX) Separator) | PrefixDecl)* ((VarDecl | FunctionDecl | OptionDecl) Separator)*
/*[7]*/  	Setter	  ::=  	BoundarySpaceDecl | DefaultCollationDecl | BaseURIDecl | ConstructionDecl | OrderingModeDecl | EmptyOrderDecl | CopyNamespacesDecl
/*[8]*/  	ImportX	  ::=  	SchemaImport | ModuleImport
/*[9]*/  	Separator	  ::=  	";"
/*[10]*/  	NamespaceDecl	  ::=  	"declare" "namespace" NCName "=" URILiteral
/*[11]*/  	BoundarySpaceDecl	  ::=  	"declare" "boundary-space" ("preserve" | "strip")
/*[12]*/  	DefaultNamespaceDecl	  ::=  	"declare" "default" ("element" | "function") "namespace" URILiteral
/*[13]*/  	OptionDecl	  ::=  	"declare" "option" QName StringLiteral
/*[14]*/  	OrderingModeDecl	  ::=  	"declare" "ordering" ("ordered" | "unordered")
/*[15]*/  	EmptyOrderDecl	  ::=  	"declare" "default" "order" "empty" ("greatest" | "least")
/*[16]*/  	CopyNamespacesDecl	  ::=  	"declare" "copy-namespaces" PreserveMode "," InheritMode
/*[17]*/  	PreserveMode	  ::=  	"preserve" | "no-preserve"
/*[18]*/  	InheritMode	  ::=  	"inherit" | "no-inherit"
/*[19]*/  	DefaultCollationDecl	  ::=  	"declare" "default" "collation" URILiteral
/*[20]*/  	BaseURIDecl	  ::=  	"declare" "base-uri" URILiteral
/*[21]*/  	SchemaImport	  ::=  	"import" "schema" SchemaPrefix? URILiteral ("at" URILiteral ("," URILiteral)*)?
/*[22]*/  	SchemaPrefix	  ::=  	("namespace" NCName "=") | ("default" "element" "namespace")
/*[23]*/  	ModuleImport	  ::=  	"import" "module" ("namespace" NCName "=")? URILiteral ("at" URILiteral ("," URILiteral)*)?
/*[24]*/  	VarDecl	  ::=  	"declare" "variable" "$" QName TypeDeclaration? ((":=" ExprSingle) | "external")
/*[25]*/  	ConstructionDecl	  ::=  	"declare" "construction" ("strip" | "preserve")
/*[26]*/  	FunctionDecl	  ::=  	"declare" "function" QName "(" ParamList? ")" ("as" SequenceType)? (EnclosedExpr | "external")
/*[27]*/  	ParamList	  ::=  	Param ("," Param)*
/*[28]*/  	Param	  ::=  	"$" QName TypeDeclaration?
/*[29]*/  	EnclosedExpr	  ::=  	"{" Expr "}"
/*[30]*/  	QueryBody	  ::=  	Expr
/*[31]*/  	Expr	  ::=  	ExprSingle ("," ExprSingle)*
/*[32]*/  	ExprSingle	  ::=  	FLWORExpr | QuantifiedExpr | TypeswitchExpr | IfExpr | OrExpr
/*[33]*/  	FLWORExpr	  ::=  	(ForClause | LetClause | SparqlForClause)+ WhereClause? OrderByClause? ReturnClause
/*[33a]*/  	ReturnClause	  ::=  	"return" ExprSingle | "construct" ConstructTemplate
/*[33b]*/  	SparqlForClause	  ::=  	"for" "distinct"? ("$" VarName ("$" Varname)* | "*") DatasetClause "where" GroupGraphPattern SolutionModifier
/*[34]*/  	ForClause	  ::=  	"for" "$" VarName TypeDeclaration? PositionalVar? "in" ExprSingle ("," "$" VarName TypeDeclaration? PositionalVar? "in" ExprSingle)*
/*[35]*/  	PositionalVar	  ::=  	"at" "$" VarName
/*[36]*/  	LetClause	  ::=  	"let" "$" VarName TypeDeclaration? ":=" ExprSingle ("," "$" VarName TypeDeclaration? ":=" ExprSingle)*
/*[37]*/  	WhereClause	  ::=  	"where" ExprSingle
/*[38]*/  	OrderByClause	  ::=  	(("order" "by") | ("stable" "order" "by")) OrderSpecList
/*[39]*/  	OrderSpecList	  ::=  	OrderSpec ("," OrderSpec)*
/*[40]*/  	OrderSpec	  ::=  	ExprSingle OrderModifier
/*[41]*/  	OrderModifier	  ::=  	("ascending" | "descending")? ("empty" ("greatest" | "least"))? ("collation" URILiteral)?
/*[42]*/  	QuantifiedExpr	  ::=  	("some" | "every") "$" VarName TypeDeclaration? "in" ExprSingle ("," "$" VarName TypeDeclaration? "in" ExprSingle)* "satisfies" ExprSingle
/*[43]*/  	TypeswitchExpr	  ::=  	"typeswitch" "(" Expr ")" CaseClause+ "default" ("$" VarName)? "return" ExprSingle
/*[44]*/  	CaseClause	  ::=  	"case" ("$" VarName "as")? SequenceType "return" ExprSingle
/*[45]*/  	IfExpr	  ::=  	"if" "(" Expr ")" "then" ExprSingle "else" ExprSingle
/*[46]*/  	OrExpr	  ::=  	AndExpr ( "or" AndExpr )*
/*[47]*/  	AndExpr	  ::=  	ComparisonExpr ( "and" ComparisonExpr )*
/*[48]*/  	ComparisonExpr	  ::=  	RangeExpr ( (ValueComp | GeneralComp | NodeComp) RangeExpr )?
/*[49]*/  	RangeExpr	  ::=  	AdditiveExpr ( "to" AdditiveExpr )?
/*[50]*/  	AdditiveExpr	  ::=  	MultiplicativeExpr ( ("+" | "-") MultiplicativeExpr )*
/*[51]*/  	MultiplicativeExpr	  ::=  	UnionExpr ( ("*" | "div" | "idiv" | "mod") UnionExpr )*
/*[52]*/  	UnionExpr	  ::=  	IntersectExceptExpr ( ("union" | "|") IntersectExceptExpr )*
/*[53]*/  	IntersectExceptExpr	  ::=  	InstanceofExpr ( ("intersect" | "except") InstanceofExpr )*
/*[54]*/  	InstanceofExpr	  ::=  	TreatExpr ( "instance" "of" SequenceType )?
/*[55]*/  	TreatExpr	  ::=  	CastableExpr ( "treat" "as" SequenceType )?
/*[56]*/  	CastableExpr	  ::=  	CastExpr ( "castable" "as" SingleType )?
/*[57]*/  	CastExpr	  ::=  	UnaryExpr ( "cast" "as" SingleType )?
/*[58]*/  	UnaryExpr	  ::=  	("-" | "+")* ValueExpr
/*[59]*/  	ValueExpr	  ::=  	ValidateExpr | PathExpr | ExtensionExpr
/*[60]*/  	GeneralComp	  ::=  	"=" | "!=" | "<" | "<=" | ">" | ">="
/*[61]*/  	ValueComp	  ::=  	"eq" | "ne" | "lt" | "le" | "gt" | "ge"
/*[62]*/  	NodeComp	  ::=  	"is" | "<<" | ">>"
/*[63]*/  	ValidateExpr	  ::=  	"validate" ValidationMode? "{" Expr "}"
/*[64]*/  	ValidationMode	  ::=  	"lax" | "strict"
/*[65]*/  	ExtensionExpr	  ::=  	Pragma+ "{" Expr? "}"
/*[66]*/  	Pragma	  ::=  	"(#" S? QName (S PragmaContents)? "#)"	/* ws: explicit */
/*[67]*/  	PragmaContents	  ::=  	(Char* - (Char* '#)' Char*))
/*[68]*/  	PathExpr	  ::=  	("/" RelativePathExpr?) | ("//" RelativePathExpr) | RelativePathExpr	/* xgs: leading-lone-slash */
/*[69]*/  	RelativePathExpr	  ::=  	StepExpr (("/" | "//") StepExpr)*
/*[70]*/  	StepExpr	  ::=  	FilterExpr | AxisStep
/*[71]*/  	AxisStep	  ::=  	(ReverseStep | ForwardStep) PredicateList
/*[72]*/  	ForwardStep	  ::=  	(ForwardAxis NodeTest) | AbbrevForwardStep
/*[73]*/  	ForwardAxis	  ::=  	("child" "::") | ("descendant" "::") | ("attribute" "::") | ("self" "::") | ("descendant-or-self" "::") | ("following-sibling" "::") | ("following" "::")
/*[74]*/  	AbbrevForwardStep	  ::=  	"@"? NodeTest
/*[75]*/  	ReverseStep	  ::=  	(ReverseAxis NodeTest) | AbbrevReverseStep
/*[76]*/  	ReverseAxis	  ::=  	("parent" "::") | ("ancestor" "::") | ("preceding-sibling" "::") | ("preceding" "::") | ("ancestor-or-self" "::")
/*[77]*/  	AbbrevReverseStep	  ::=  	".."
/*[78]*/  	NodeTest	  ::=  	KindTest | NameTest
/*[79]*/  	NameTest	  ::=  	QName | Wildcard
/*[80]*/  	Wildcard	  ::=  	"*" | (NCName ":" "*") | ("*" ":" NCName)	/* ws: explicit */
/*[81]*/  	FilterExpr	  ::=  	PrimaryExpr PredicateList
/*[82]*/  	PredicateList	  ::=  	Predicate*
/*[83]*/  	Predicate	  ::=  	"[" Expr "]"
/*[84]*/  	PrimaryExpr	  ::=  	Literal | VarRef | ParenthesizedExpr | ContextItemExpr | FunctionCall | OrderedExpr | UnorderedExpr | Constructor
/*[85]*/  	Literal	  ::=  	NumericLiteral | StringLiteral
/*[86]*/  	NumericLiteral	  ::=  	IntegerLiteral | DecimalLiteral | DoubleLiteral
/*[87]*/  	VarRef	  ::=  	"$" VarName
/*[88]*/  	VarName	  ::=  	QName
/*[89]*/  	ParenthesizedExpr	  ::=  	"(" Expr? ")"
/*[90]*/  	ContextItemExpr	  ::=  	"."
/*[91]*/  	OrderedExpr	  ::=  	"ordered" "{" Expr "}"
/*[92]*/  	UnorderedExpr	  ::=  	"unordered" "{" Expr "}"
/*[93]*/  	FunctionCall	  ::=  	QName "(" (ExprSingle ("," ExprSingle)*)? ")"	/* xgs: reserved-function-names */ /* gn: parens */
/*[94]*/  	Constructor	  ::=  	DirectConstructor | ComputedConstructor
/*[95]*/  	DirectConstructor	  ::=  	DirElemConstructor | DirCommentConstructor | DirPIConstructor
/*[96]*/  	DirElemConstructor	  ::=  	"<" QName DirAttributeList ("/>" | (">" DirElemContent* "</" QName S? ">"))	/* ws: explicit */
/*[97]*/  	DirAttributeList	  ::=  	(S (QName S? "=" S? DirAttributeValue)?)*	/* ws: explicit */
/*[98]*/  	DirAttributeValue	  ::=  	('"' (EscapeQuot | QuotAttrValueContent)* '"') | ("'" (EscapeApos | AposAttrValueContent)* "'")	/* ws: explicit */
/*[99]*/  	QuotAttrValueContent	  ::=  	QuotAttrContentChar | CommonContent
/*[100]*/  	AposAttrValueContent	  ::=  	AposAttrContentChar | CommonContent
/*[101]*/  	DirElemContent	  ::=  	DirectConstructor | CDataSection | CommonContent | ElementContentChar
/*[102]*/  	CommonContent	  ::=  	PredefinedEntityRef | CharRef | "{{" | "}}" | EnclosedExpr
/*[103]*/  	DirCommentConstructor	  ::=  	"<!--" DirCommentContents "-->"	/* ws: explicit */
/*[104]*/  	DirCommentContents	  ::=  	((Char - '-') | ('-' (Char - '-')))*	/* ws: explicit */
/*[105]*/  	DirPIConstructor	  ::=  	"<?" PITarget (S DirPIContents)? "?>"	/* ws: explicit */
/*[106]*/  	DirPIContents	  ::=  	(Char* - (Char* '?>' Char*))	/* ws: explicit */
/*[107]*/  	CDataSection	  ::=  	"<![CDATA[" CDataSectionContents "]]>"	/* ws: explicit */
/*[108]*/  	CDataSectionContents	  ::=  	(Char* - (Char* ']]>' Char*))	/* ws: explicit */
/*[109]*/  	ComputedConstructor	  ::=  	CompDocConstructor | CompElemConstructor | CompAttrConstructor | CompTextConstructor | CompCommentConstructor | CompPIConstructor
/*[110]*/  	CompDocConstructor	  ::=  	"document" "{" Expr "}"
/*[111]*/  	CompElemConstructor	  ::=  	"element" (QName | ("{" Expr "}")) "{" ContentExpr? "}"
/*[112]*/  	ContentExpr	  ::=  	Expr
/*[113]*/  	CompAttrConstructor	  ::=  	"attribute" (QName | ("{" Expr "}")) "{" Expr? "}"
/*[114]*/  	CompTextConstructor	  ::=  	"text" "{" Expr "}"
/*[115]*/  	CompCommentConstructor	  ::=  	"comment" "{" Expr "}"
/*[116]*/  	CompPIConstructor	  ::=  	"processing-instruction" (NCName | ("{" Expr "}")) "{" Expr? "}"
/*[117]*/  	SingleType	  ::=  	AtomicType "?"?
/*[118]*/  	TypeDeclaration	  ::=  	"as" SequenceType
/*[119]*/  	SequenceType	  ::=  	("empty-sequence" "(" ")") | (ItemType OccurrenceIndicator?)
/*[120]*/  	OccurrenceIndicator	  ::=  	"?" | "*" | "+"	/* xgs: occurrence-indicators */
/*[121]*/  	ItemType	  ::=  	KindTest | ("item" "(" ")") | AtomicType
/*[122]*/  	AtomicType	  ::=  	QName
/*[123]*/  	KindTest	  ::=  	DocumentTest | ElementTest | AttributeTest | SchemaElementTest | SchemaAttributeTest | PITest | CommentTest | TextTest | AnyKindTest
/*[124]*/  	AnyKindTest	  ::=  	"node" "(" ")"
/*[125]*/  	DocumentTest	  ::=  	"document-node" "(" (ElementTest | SchemaElementTest)? ")"
/*[126]*/  	TextTest	  ::=  	"text" "(" ")"
/*[127]*/  	CommentTest	  ::=  	"comment" "(" ")"
/*[128]*/  	PITest	  ::=  	"processing-instruction" "(" (NCName | StringLiteral)? ")"
/*[129]*/  	AttributeTest	  ::=  	"attribute" "(" (AttribNameOrWildcard ("," TypeName)?)? ")"
/*[130]*/  	AttribNameOrWildcard	  ::=  	AttributeName | "*"
/*[131]*/  	SchemaAttributeTest	  ::=  	"schema-attribute" "(" AttributeDeclaration ")"
/*[132]*/  	AttributeDeclaration	  ::=  	AttributeName
/*[133]*/  	ElementTest	  ::=  	"element" "(" (ElementNameOrWildcard ("," TypeName "?"?)?)? ")"
/*[134]*/  	ElementNameOrWildcard	  ::=  	ElementName | "*"
/*[135]*/  	SchemaElementTest	  ::=  	"schema-element" "(" ElementDeclaration ")"
/*[136]*/  	ElementDeclaration	  ::=  	ElementName
/*[137]*/  	AttributeName	  ::=  	QName
/*[138]*/  	ElementName	  ::=  	QName
/*[139]*/  	TypeName	  ::=  	QName
/*[140]*/  	URILiteral	  ::=  	StringLiteral

/* SPARQL Non terminals */
/*[1]*/  	Query	  ::=  	Prologue ( SelectQuery | ConstructQuery | DescribeQuery | AskQuery )
/*[2]*/  	Prologue	  ::=  	BaseDecl? PrefixDecl*
/*[3]*/  	BaseDecl	  ::=  	'BASE' IRI_REF
/*[4]*/  	PrefixDecl	  ::=  	'PREFIX' PNAME_NS IRI_REF
/*[5]*/  	SelectQuery	  ::=  	'SELECT' ( 'DISTINCT' | 'REDUCED' )? ( Var+ | '*' ) DatasetClause* WhereClause SolutionModifier
/*[6]*/  	ConstructQuery	  ::=  	'CONSTRUCT' ConstructTemplate DatasetClause* WhereClause SolutionModifier
/*[7]*/  	DescribeQuery	  ::=  	'DESCRIBE' ( VarOrIRIref+ | '*' ) DatasetClause* WhereClause? SolutionModifier
/*[8]*/  	AskQuery	  ::=  	'ASK' DatasetClause* WhereClause
/*[9]*/  	DatasetClause	  ::=  	'FROM' ( DefaultGraphClause | NamedGraphClause)
/*[10]*/  	DefaultGraphClause	  ::=  	SourceSelector
/*[11]*/  	NamedGraphClause	  ::=  	'NAMED' SourceSelector
/*[12]*/  	SourceSelector	  ::=  	IRIref | Var
/*[13]*/  	WhereClause	  ::=  	'WHERE'? GroupGraphPattern
/*[14]*/  	SolutionModifier	  ::=  	OrderClause? LimitOffsetClauses?
/*[15]*/  	LimitOffsetClauses	  ::=  	( LimitClause OffsetClause? | OffsetClause LimitClause? )
/*[16]*/  	OrderClause	  ::=  	'ORDER' 'BY' OrderCondition+
/*[17]*/  	OrderCondition	  ::=  	( ( 'ASC' | 'DESC' ) BrackettedExpression ) | ( Constraint | Var )
/*[18]*/  	LimitClause	  ::=  	'LIMIT' INTEGER
/*[19]*/  	OffsetClause	  ::=  	'OFFSET' INTEGER
/*[20]*/  	GroupGraphPattern	  ::=  	'{' TriplesBlock? ( ( GraphPatternNotTriples | Filter ) '.'? TriplesBlock? )* '}'
/*[21]*/  	TriplesBlock	  ::=  	TriplesSameSubject ( '.' TriplesBlock? )?
/*[22]*/  	GraphPatternNotTriples	  ::=  	OptionalGraphPattern | GroupOrUnionGraphPattern | GraphGraphPattern
/*[23]*/  	OptionalGraphPattern	  ::=  	'OPTIONAL' GroupGraphPattern
/*[24]*/  	GraphGraphPattern	  ::=  	'GRAPH' VarOrIRIref GroupGraphPattern
/*[25]*/  	GroupOrUnionGraphPattern	  ::=  	GroupGraphPattern ( 'UNION' GroupGraphPattern )*
/*[26]*/  	Filter	  ::=  	'FILTER' Constraint
/*[27]*/  	Constraint	  ::=  	BrackettedExpression | BuiltInCall | FunctionCall
/*[28]*/  	FunctionCall	  ::=  	IRIref ArgList
/*[29]*/  	ArgList	  ::=  	( NIL | '(' Expression ( ',' Expression )* ')' )
/*[30]*/  	ConstructTemplate	  ::=  	'{' ConstructTriples? '}'
/*[31]*/  	ConstructTriples	  ::=  	TriplesSameSubject1 ( '.' ConstructTriples? )?
/*[32]*/  	TriplesSameSubject	  ::=  	VarOrTerm PropertyListNotEmpty |	TriplesNode PropertyList
/*[32']*/ 	TriplesSameSubject1	  ::=  	VarOrTerm1 PropertyListNotEmpty1 |	TriplesNode1 PropertyList1
/*[33]*/  	PropertyListNotEmpty	  ::=  	Verb ObjectList ( ';' ( Verb ObjectList )? )*
/*[33']*/ 	PropertyListNotEmpty1	  ::=  	Verb1 ObjectList1 ( ';' ( Verb1 ObjectList1 )? )*
/*[34]*/ 	PropertyList	  ::=  	PropertyListNotEmpty?
/*[34']*/ 	PropertyList1	  ::=  	PropertyListNotEmpty1?
/*[35]*/  	ObjectList	  ::=  	Object ( ',' Object )*
/*[35']*/ 	ObjectList1	  ::=  	Object1 ( ',' Object1 )*
/*[36]*/  	Object	  ::=  	GraphNode
/*[36']*/ 	Object1	  ::=  	GraphNode1
/*[37]*/  	Verb	  ::=  	VarOrIRIref | 'a'
/*[37']*/ 	Verb1	  ::=  	VarOrIRIref1 | 'a'
/*[38]*/  	TriplesNode	  ::=  	Collection |	BlankNodePropertyList
/*[38']*/ 	TriplesNode1	  ::=  	Collection1 |	BlankNodePropertyList1
/*[39]*/  	BlankNodePropertyList	  ::=  	'[' PropertyListNotEmpty ']'
/*[39']*/ 	BlankNodePropertyList1	  ::=  	'[' PropertyListNotEmpty1 ']'
/*[40]*/  	Collection	  ::=  	'(' GraphNode+ ')'
/*[40']*/ 	Collection1	  ::=  	'(' GraphNode1+ ')'
/*[41]*/  	GraphNode	  ::=  	VarOrTerm |	TriplesNode
/*[41']*/ 	GraphNode1	  ::=  	VarOrTerm1 |	TriplesNode1
/*[42]*/  	VarOrTerm	  ::=  	Var | GraphTerm
/*[42']*/ 	VarOrTerm1	  ::=  	Var | GraphTerm1
/*[43]*/  	VarOrIRIref	  ::=  	Var | IRIref
/*[43']*/ 	VarOrIRIref1	  ::=  	Var | IRIref1
/*[44]*/  	Var	  ::=  	VAR1 | VAR2
/*[45]*/  	GraphTerm	  ::=  	IRIref |	RDFLiteral |	NumericLiteral |	BooleanLiteral |	BlankNode |	NIL
/*[45']*/ 	GraphTerm1	  ::=  	IRIref |	RDFLiteral1 | NumericLiteral |	BooleanLiteral |	BlankNode1 |	NIL
/*[46]*/  	Expression	  ::=  	ConditionalOrExpression
/*[47]*/  	ConditionalOrExpression	  ::=  	ConditionalAndExpression ( '||' ConditionalAndExpression )*
/*[48]*/  	ConditionalAndExpression	  ::=  	ValueLogical ( '&&' ValueLogical )*
/*[49]*/  	ValueLogical	  ::=  	RelationalExpression
/*[50]*/  	RelationalExpression	  ::=  	NumericExpression ( '=' NumericExpression | '!=' NumericExpression | '<' NumericExpression | '>' NumericExpression | '<=' NumericExpression | '>=' NumericExpression )?
/*[51]*/  	NumericExpression	  ::=  	AdditiveExpression
/*[52]*/  	AdditiveExpression	  ::=  	MultiplicativeExpression ( '+' MultiplicativeExpression | '-' MultiplicativeExpression | NumericLiteralPositive | NumericLiteralNegative )*
/*[53]*/  	MultiplicativeExpression	  ::=  	UnaryExpression ( '*' UnaryExpression | '/' UnaryExpression )*
/*[54]*/  	UnaryExpression	  ::=  	  '!' PrimaryExpression  |	'+' PrimaryExpression  |	'-' PrimaryExpression  |	PrimaryExpression
/*[55]*/  	PrimaryExpression	  ::=  	BrackettedExpression | BuiltInCall | IRIrefOrFunction | RDFLiteral | NumericLiteral | BooleanLiteral | Var
/*[56]*/  	BrackettedExpression	  ::=  	'(' Expression ')'
/*[57]*/  	BuiltInCall	  ::=  	  'STR' '(' Expression ')'  |	'LANG' '(' Expression ')'  |	'LANGMATCHES' '(' Expression ',' Expression ')'  |	'DATATYPE' '(' Expression ')'  |	'BOUND' '(' Var ')'  |	'sameTerm' '(' Expression ',' Expression ')'  |	'isIRI' '(' Expression ')'  |	'isURI' '(' Expression ')'  |	'isBLANK' '(' Expression ')'  |	'isLITERAL' '(' Expression ')'  |	RegexExpression
/*[58]*/  	RegexExpression	  ::=  	'REGEX' '(' Expression ',' Expression ( ',' Expression )? ')'
/*[59]*/  	IRIrefOrFunction	  ::=  	IRIref ArgList?
/*[60]*/  	RDFLiteral	  ::=  	String ( LANGTAG | ( '^^' IRIref ) )?
/*[60']*/  	RDFLiteral1	  ::=  	String1 ( LANGTAG | '@{' FLWORExpr '}' | ( '^^' IRIref1) )?
/*[61]*/  	NumericLiteral	  ::=  	NumericLiteralUnsigned | NumericLiteralPositive | NumericLiteralNegative
/*[62]*/  	NumericLiteralUnsigned	  ::=  	INTEGER |	DECIMAL |	DOUBLE
/*[63]*/  	NumericLiteralPositive	  ::=  	INTEGER_POSITIVE |	DECIMAL_POSITIVE |	DOUBLE_POSITIVE
/*[64]*/  	NumericLiteralNegative	  ::=  	INTEGER_NEGATIVE |	DECIMAL_NEGATIVE |	DOUBLE_NEGATIVE
/*[65]*/  	BooleanLiteral	  ::=  	'true' |	'false'
/*[66]*/  	String	  ::=  	STRING_LITERAL1 | STRING_LITERAL2 | STRING_LITERAL_LONG1 | STRING_LITERAL_LONG2
/*[66']*/  	String1	  ::=  	STRING_LITERAL1 | STRING_LITERAL2 | STRING_LITERAL_LONG1 | STRING_LITERAL_LONG2 | '{' FLWORExpr '}'
/*[67]*/  	IRIref	  ::=  	IRI_REF |	PrefixedName
/*[67']*/  	IRIref1	  ::=  	IRI_REF | '<{' FLWORExpr '}>' | PrefixedName1
/*[68]*/  	PrefixedName	  ::=  	PNAME_LN | PNAME_NS
/*[68']*/  	PrefixedName1	  ::=  	PNAME_LN( (PN_PREFIX | '{' FLWORExpr '}')? ':' (PN_LOCAL | '{' FLWORExpr '}') ) | PNAME_NS
/*[69]*/  	BlankNode	  ::=  	BLANK_NODE_LABEL |	ANON
/*[69']*/  	BlankNode1	  ::=  	BLANK_NODE_LABEL |	ANON | '_:{' FLWORExpr '}'
